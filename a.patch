From 8744e64f1d888921b6f7cac1ebacc31d86e48cd4 Mon Sep 17 00:00:00 2001
From: Matthew Penner <me@matthewp.io>
Date: Wed, 28 Aug 2024 19:31:50 -0600
Subject: [PATCH] fix: update `ufs`, fix issues with network filesystems and
 random file not found during directory walking

Signed-off-by: Matthew Penner <me@matthewp.io>
---
 internal/ufs/README.md       |   6 +-
 internal/ufs/error.go        |   2 +
 internal/ufs/file.go         |   1 +
 internal/ufs/fs_quota.go     |   4 +
 internal/ufs/fs_unix.go      | 124 ++++-----
 internal/ufs/fs_unix_test.go | 523 ++++++++++++++++++++++++++++++++++-
 internal/ufs/quota_writer.go |  12 +-
 internal/ufs/walk.go         |   1 +
 internal/ufs/walk_unix.go    |  76 +++--
 9 files changed, 644 insertions(+), 105 deletions(-)

diff --git a/internal/ufs/README.md b/internal/ufs/README.md
index 3f67df3..c9a8441 100644
--- a/internal/ufs/README.md
+++ b/internal/ufs/README.md
@@ -1,5 +1,9 @@
 # Filesystem
 
+Coming Soon&trade;
+
+> TODO
+
 ## Licensing
 
 Most code in this package is licensed under `MIT` with some exceptions.
@@ -11,7 +15,7 @@ verbatim or derived from [Go](https://go.dev)'s source code.
 - [`mkdir_unix.go`](./mkdir_unix.go)
 - [`path_unix.go`](./path_unix.go)
 - [`removeall_unix.go`](./removeall_unix.go)
-- [`stat_unix.go`](./stat_unix.go) 
+- [`stat_unix.go`](./stat_unix.go)
 - [`walk.go`](./walk.go)
 
 These changes are not associated with nor endorsed by The Go Authors.
diff --git a/internal/ufs/error.go b/internal/ufs/error.go
index 0ba5262..dc563e4 100644
--- a/internal/ufs/error.go
+++ b/internal/ufs/error.go
@@ -114,6 +114,8 @@ func convertErrorType(err error) error {
 				Path: pErr.Path,
 				Err:  ErrBadPathResolution,
 			}
+			// TODO: EROFS
+			// TODO: ENOTEMPTY
 		}
 	}
 	return err
diff --git a/internal/ufs/file.go b/internal/ufs/file.go
index bcdd189..9902c8b 100644
--- a/internal/ufs/file.go
+++ b/internal/ufs/file.go
@@ -146,6 +146,7 @@ const (
 	ModePerm = iofs.ModePerm
 )
 
+// Re-using the same names as Go's official `unix` and `os` package do.
 const (
 	// O_RDONLY opens the file read-only.
 	O_RDONLY = unix.O_RDONLY
diff --git a/internal/ufs/fs_quota.go b/internal/ufs/fs_quota.go
index 5c6e5ef..600a9fa 100644
--- a/internal/ufs/fs_quota.go
+++ b/internal/ufs/fs_quota.go
@@ -7,6 +7,8 @@ import (
 	"sync/atomic"
 )
 
+// Quota .
+// TODO: document
 type Quota struct {
 	// fs is the underlying filesystem that runs the actual I/O operations.
 	*UnixFS
@@ -26,6 +28,8 @@ type Quota struct {
 	usage atomic.Int64
 }
 
+// NewQuota .
+// TODO: document
 func NewQuota(fs *UnixFS, limit int64) *Quota {
 	qfs := Quota{UnixFS: fs}
 	qfs.limit.Store(limit)
diff --git a/internal/ufs/fs_unix.go b/internal/ufs/fs_unix.go
index 36ba77c..a6842b2 100644
--- a/internal/ufs/fs_unix.go
+++ b/internal/ufs/fs_unix.go
@@ -12,7 +12,6 @@ import (
 	"path/filepath"
 	"strconv"
 	"strings"
-	"sync/atomic"
 	"time"
 
 	"golang.org/x/sys/unix"
@@ -26,10 +25,6 @@ type UnixFS struct {
 	// basePath is the base path for file operations to take place in.
 	basePath string
 
-	// dirfd holds the file descriptor of BasePath and is used to ensure
-	// operations are restricted into descendants of BasePath.
-	dirfd atomic.Int64
-
 	// useOpenat2 controls whether the `openat2` syscall is used instead of the
 	// older `openat` syscall.
 	useOpenat2 bool
@@ -41,18 +36,10 @@ type UnixFS struct {
 // checked and prevented from enabling an escape in a non-raceable manor.
 func NewUnixFS(basePath string, useOpenat2 bool) (*UnixFS, error) {
 	basePath = strings.TrimSuffix(basePath, "/")
-	// We don't need Openat2, if we are given a basePath that is already unsafe
-	// I give up on trying to sandbox it.
-	dirfd, err := unix.Openat(AT_EMPTY_PATH, basePath, O_DIRECTORY|O_RDONLY, 0)
-	if err != nil {
-		return nil, convertErrorType(err)
-	}
-
 	fs := &UnixFS{
 		basePath:   basePath,
 		useOpenat2: useOpenat2,
 	}
-	fs.dirfd.Store(int64(dirfd))
 	return fs, nil
 }
 
@@ -66,12 +53,7 @@ func (fs *UnixFS) BasePath() string {
 // Close releases the file descriptor used to sandbox operations within the
 // base path of the filesystem.
 func (fs *UnixFS) Close() error {
-	// Once closed, change dirfd to something invalid to detect when it has been
-	// closed.
-	defer func() {
-		fs.dirfd.Store(-1)
-	}()
-	return unix.Close(int(fs.dirfd.Load()))
+	return nil
 }
 
 // Chmod changes the mode of the named file to mode.
@@ -294,8 +276,10 @@ func (fs *UnixFS) ReadDir(path string) ([]DirEntry, error) {
 	if err != nil {
 		return nil, err
 	}
-	defer unix.Close(fd)
-	return fs.readDir(fd, name, nil)
+	defer func() {
+		_ = unix.Close(fd)
+	}()
+	return fs.readDir(fd, name, ".", nil)
 }
 
 // RemoveStat is a combination of Stat and Remove, it is used to more
@@ -496,13 +480,13 @@ func (fs *UnixFS) Rename(oldpath, newpath string) error {
 //
 // If there is an error, it will be of type *PathError.
 func (fs *UnixFS) Stat(name string) (FileInfo, error) {
-	return fs.fstat(name, 0)
+	return fs._fstat("stat", name, 0)
 }
 
 // Statat is like Stat but allows passing an existing directory file
 // descriptor rather than needing to resolve one.
 func (fs *UnixFS) Statat(dirfd int, name string) (FileInfo, error) {
-	return fs.fstatat(dirfd, name, 0)
+	return fs._fstatat("statat", dirfd, name, 0)
 }
 
 // Lstat returns a FileInfo describing the named file.
@@ -512,30 +496,38 @@ func (fs *UnixFS) Statat(dirfd int, name string) (FileInfo, error) {
 //
 // If there is an error, it will be of type *PathError.
 func (fs *UnixFS) Lstat(name string) (FileInfo, error) {
-	return fs.fstat(name, AT_SYMLINK_NOFOLLOW)
+	return fs._fstat("lstat", name, AT_SYMLINK_NOFOLLOW)
 }
 
 // Lstatat is like Lstat but allows passing an existing directory file
 // descriptor rather than needing to resolve one.
 func (fs *UnixFS) Lstatat(dirfd int, name string) (FileInfo, error) {
-	return fs.fstatat(dirfd, name, AT_SYMLINK_NOFOLLOW)
+	return fs._fstatat("lstatat", dirfd, name, AT_SYMLINK_NOFOLLOW)
 }
 
 func (fs *UnixFS) fstat(name string, flags int) (FileInfo, error) {
+	return fs._fstat("fstat", name, flags)
+}
+
+func (fs *UnixFS) _fstat(op string, name string, flags int) (FileInfo, error) {
 	dirfd, name, closeFd, err := fs.safePath(name)
 	defer closeFd()
 	if err != nil {
 		return nil, err
 	}
-	return fs.fstatat(dirfd, name, flags)
+	return fs._fstatat(op, dirfd, name, flags)
 }
 
 func (fs *UnixFS) fstatat(dirfd int, name string, flags int) (FileInfo, error) {
+	return fs._fstatat("fstatat", dirfd, name, flags)
+}
+
+func (fs *UnixFS) _fstatat(op string, dirfd int, name string, flags int) (FileInfo, error) {
 	var s fileStat
 	if err := ignoringEINTR(func() error {
 		return unix.Fstatat(dirfd, name, &s.sys, flags)
 	}); err != nil {
-		return nil, &PathError{Op: "stat", Path: name, Err: err}
+		return nil, &PathError{Op: op, Path: name, Err: err}
 	}
 	fillFileStatFromSys(&s, name)
 	return &s, nil
@@ -632,39 +624,45 @@ func (fs *UnixFS) openat(dirfd int, name string, flag int, mode FileMode) (int,
 		return 0, convertErrorType(err)
 	}
 
+	// If we are using openat2, we don't need the additional security checks.
+	if fs.useOpenat2 {
+		return fd, nil
+	}
+
 	// If we are not using openat2, do additional path checking. This assumes
 	// that openat2 is using `RESOLVE_BENEATH` to avoid the same security
 	// issue.
-	if !fs.useOpenat2 {
-		var finalPath string
-		finalPath, err := filepath.EvalSymlinks(filepath.Join("/proc/self/fd/", strconv.Itoa(dirfd)))
-		if err != nil {
-			return fd, convertErrorType(err)
-		}
-		if err != nil {
-			if !errors.Is(err, ErrNotExist) {
-				return fd, fmt.Errorf("failed to evaluate symlink: %w", convertErrorType(err))
-			}
-
-			// The target of one of the symlinks (EvalSymlinks is recursive)
-			// does not exist. So get the path that does not exist and use
-			// that for further validation instead.
-			var pErr *PathError
-			if ok := errors.As(err, &pErr); !ok {
-				return fd, fmt.Errorf("failed to evaluate symlink: %w", convertErrorType(err))
-			}
-			finalPath = pErr.Path
+	var finalPath string
+	finalPath, err := filepath.EvalSymlinks(filepath.Join("/proc/self/fd/", strconv.Itoa(fd)))
+	if err != nil {
+		if !errors.Is(err, ErrNotExist) {
+			return fd, fmt.Errorf("failed to evaluate symlink: %w", convertErrorType(err))
 		}
 
-		// Check if the path is within our root.
-		if !fs.unsafeIsPathInsideOfBase(finalPath) {
-			return fd, convertErrorType(&PathError{
-				Op:   "openat",
-				Path: name,
-				Err:  ErrBadPathResolution,
-			})
+		// The target of one of the symlinks (EvalSymlinks is recursive)
+		// does not exist. So get the path that does not exist and use
+		// that for further validation instead.
+		var pErr *PathError
+		if !errors.As(err, &pErr) {
+			return fd, fmt.Errorf("failed to evaluate symlink: %w", convertErrorType(err))
 		}
+		finalPath = pErr.Path
+	}
+
+	// Check if the path is within our root.
+	if !fs.unsafeIsPathInsideOfBase(finalPath) {
+		return fd, convertErrorType(&PathError{
+			Op:   "openat",
+			Path: name,
+			Err:  ErrBadPathResolution,
+		})
 	}
+
+	// This handles any hanging errors.
+	if err != nil {
+		return fd, convertErrorType(err)
+	}
+
 	return fd, nil
 }
 
@@ -697,7 +695,7 @@ func (fs *UnixFS) _openat(dirfd int, name string, flag int, mode uint32) (int, e
 // present in Kernel 5.6 and above.
 //
 // This method should never be directly called, use `openat` instead.
-func (fs *UnixFS) _openat2(dirfd int, name string, flag uint64, mode uint64) (int, error) {
+func (fs *UnixFS) _openat2(dirfd int, name string, flag, mode uint64) (int, error) {
 	// Ensure the O_CLOEXEC flag is set.
 	// Go sets this when using the os package, but since we are directly using
 	// the unix package we need to set it ourselves.
@@ -745,11 +743,11 @@ func (fs *UnixFS) safePath(path string) (dirfd int, file string, closeFd func(),
 		return
 	}
 
-	// Check if dirfd was closed, this will happen if (*UnixFS).Close()
-	// was called.
-	fsDirfd := int(fs.dirfd.Load())
-	if fsDirfd == -1 {
-		err = ErrClosed
+	// Open the base path. We use this as the sandbox root for any further
+	// operations.
+	var fsDirfd int
+	fsDirfd, err = unix.Openat(AT_EMPTY_PATH, fs.basePath, O_DIRECTORY|O_RDONLY, 0)
+	if err != nil {
 		return
 	}
 
@@ -759,9 +757,8 @@ func (fs *UnixFS) safePath(path string) (dirfd int, file string, closeFd func(),
 	dir, file = filepath.Split(name)
 	// If dir is empty then name is not nested.
 	if dir == "" {
-		// We don't need to set closeFd here as it will default to a NO-OP and
-		// `fs.dirfd` is re-used until the filesystem is no-longer needed.
 		dirfd = fsDirfd
+		closeFd = func() { _ = unix.Close(dirfd) }
 
 		// Return dirfd, name, an empty closeFd func, and no error
 		return
@@ -773,7 +770,10 @@ func (fs *UnixFS) safePath(path string) (dirfd int, file string, closeFd func(),
 	dirfd, err = fs.openat(fsDirfd, dir, O_DIRECTORY|O_RDONLY, 0)
 	if dirfd != 0 {
 		// Set closeFd to close the newly opened directory file descriptor.
-		closeFd = func() { _ = unix.Close(dirfd) }
+		closeFd = func() {
+			_ = unix.Close(dirfd)
+			_ = unix.Close(fsDirfd)
+		}
 	}
 
 	// Return dirfd, name, the closeFd func, and err
diff --git a/internal/ufs/fs_unix_test.go b/internal/ufs/fs_unix_test.go
index 3cf3b37..e64bb82 100644
--- a/internal/ufs/fs_unix_test.go
+++ b/internal/ufs/fs_unix_test.go
@@ -9,6 +9,9 @@ import (
 	"errors"
 	"os"
 	"path/filepath"
+	"reflect"
+	"slices"
+	"strconv"
 	"testing"
 
 	"github.com/pterodactyl/wings/internal/ufs"
@@ -35,8 +38,8 @@ func newTestUnixFS() (*testUnixFS, error) {
 	if err := os.Mkdir(root, 0o755); err != nil {
 		return nil, err
 	}
-	// TODO: test both disabled and enabled.
-	fs, err := ufs.NewUnixFS(root, false)
+	// fmt.Println(tmpDir)
+	fs, err := ufs.NewUnixFS(root, true)
 	if err != nil {
 		return nil, err
 	}
@@ -48,6 +51,323 @@ func newTestUnixFS() (*testUnixFS, error) {
 	return tfs, nil
 }
 
+func TestUnixFS(t *testing.T) {
+	t.Parallel()
+
+	fs, err := newTestUnixFS()
+	if err != nil {
+		t.Fatal(err)
+		return
+	}
+	defer fs.Cleanup()
+
+	// Test creating a file within the root.
+	_, _, closeFd, err := fs.SafePath("/")
+	closeFd()
+	if err != nil {
+		t.Error(err)
+		return
+	}
+
+	f, err := fs.Touch("directory/file", ufs.O_RDWR, 0o644)
+	if err != nil {
+		t.Error(err)
+		return
+	}
+	_ = f.Close()
+
+	// Test creating a file within the root.
+	f, err = fs.Create("test")
+	if err != nil {
+		t.Error(err)
+		return
+	}
+	_ = f.Close()
+
+	// Test stating a file within the root.
+	if _, err := fs.Stat("test"); err != nil {
+		t.Error(err)
+		return
+	}
+
+	// Test creating a directory within the root.
+	if err := fs.Mkdir("ima_directory", 0o755); err != nil {
+		t.Error(err)
+		return
+	}
+
+	// Test creating a nested directory within the root.
+	if err := fs.Mkdir("ima_directory/ima_nother_directory", 0o755); err != nil {
+		t.Error(err)
+		return
+	}
+
+	// Test creating a file inside a directory within the root.
+	f, err = fs.Create("ima_directory/ima_file")
+	if err != nil {
+		t.Error(err)
+		return
+	}
+	_ = f.Close()
+
+	// Test listing directory entries.
+	if _, err := fs.ReadDir("ima_directory"); err != nil {
+		t.Error(err)
+		return
+	}
+
+	// Test symlink pointing outside the root.
+	if err := os.Symlink(fs.TmpDir, filepath.Join(fs.Root, "ima_bad_link")); err != nil {
+		t.Error(err)
+		return
+	}
+	f, err = fs.Create("ima_bad_link/ima_bad_file")
+	if err == nil {
+		_ = f.Close()
+		t.Error("expected an error")
+		return
+	}
+	if err := fs.Mkdir("ima_bad_link/ima_bad_directory", 0o755); err == nil {
+		t.Error("expected an error")
+		return
+	}
+
+	// Test symlink pointing outside the root inside a parent directory.
+	if err := fs.Symlink(fs.TmpDir, filepath.Join(fs.Root, "ima_directory/ima_bad_link")); err != nil {
+		t.Error(err)
+		return
+	}
+	if err := fs.Mkdir("ima_directory/ima_bad_link/ima_bad_directory", 0o755); err == nil {
+		t.Error("expected an error")
+		return
+	}
+
+	// Test symlink pointing outside the root with a child directory.
+	if err := os.Mkdir(filepath.Join(fs.TmpDir, "ima_directory"), 0o755); err != nil {
+		t.Error(err)
+		return
+	}
+	f, err = fs.Create("ima_bad_link/ima_directory/ima_bad_file")
+	if err == nil {
+		_ = f.Close()
+		t.Error("expected an error")
+		return
+	}
+	if err := fs.Mkdir("ima_bad_link/ima_directory/ima_bad_directory", 0o755); err == nil {
+		t.Error("expected an error")
+		return
+	}
+
+	if _, err := fs.ReadDir("ima_bad_link/ima_directory"); err == nil {
+		t.Error("expected an error")
+		return
+	}
+
+	// Create multiple nested directories.
+	if err := fs.MkdirAll("ima_directory/ima_directory/ima_directory/ima_directory", 0o755); err != nil {
+		t.Error(err)
+		return
+	}
+	if _, err := fs.ReadDir("ima_directory/ima_directory"); err != nil {
+		t.Error(err)
+		return
+	}
+
+	// Test creating a directory under a symlink with a pre-existing directory.
+	if err := fs.MkdirAll("ima_bad_link/ima_directory/ima_bad_directory/ima_bad_directory", 0o755); err == nil {
+		t.Error("expected an error")
+		return
+	}
+
+	// Test deletion
+	if err := fs.Remove("test"); err != nil {
+		t.Error(err)
+		return
+	}
+	if err := fs.Remove("ima_bad_link"); err != nil {
+		t.Error(err)
+		return
+	}
+
+	// Test recursive deletion
+	if err := fs.RemoveAll("ima_directory"); err != nil {
+		t.Error(err)
+		return
+	}
+
+	// Test recursive deletion underneath a bad symlink
+	if err := fs.Mkdir("ima_directory", 0o755); err != nil {
+		t.Error(err)
+		return
+	}
+	if err := fs.Symlink(fs.TmpDir, filepath.Join(fs.Root, "ima_directory/ima_bad_link")); err != nil {
+		t.Error(err)
+		return
+	}
+	if err := fs.RemoveAll("ima_directory/ima_bad_link/ima_bad_file"); err == nil {
+		t.Error("expected an error")
+		return
+	}
+
+	// This should delete the symlink itself.
+	if err := fs.RemoveAll("ima_directory/ima_bad_link"); err != nil {
+		t.Error(err)
+		return
+	}
+
+	//for i := 0; i < 5; i++ {
+	//	dirName := "dir" + strconv.Itoa(i)
+	//	if err := fs.Mkdir(dirName, 0o755); err != nil {
+	//		t.Error(err)
+	//		return
+	//	}
+	//	for j := 0; j < 5; j++ {
+	//		f, err := fs.Create(filepath.Join(dirName, "file"+strconv.Itoa(j)))
+	//		if err != nil {
+	//			t.Error(err)
+	//			return
+	//		}
+	//		_ = f.Close()
+	//	}
+	//}
+	//
+	//if err := fs.WalkDir2("", func(fd int, path string, info filesystem.DirEntry, err error) error {
+	//	if err != nil {
+	//		return err
+	//	}
+	//	fmt.Println(path)
+	//	return nil
+	//}); err != nil {
+	//	t.Error(err)
+	//	return
+	//}
+}
+
+func TestUnixFS_Chmod(t *testing.T) {
+	t.Parallel()
+	fs, err := newTestUnixFS()
+	if err != nil {
+		t.Fatal(err)
+		return
+	}
+	defer fs.Cleanup()
+
+	// TODO: implement
+}
+
+func TestUnixFS_Chown(t *testing.T) {
+	t.Parallel()
+	fs, err := newTestUnixFS()
+	if err != nil {
+		t.Fatal(err)
+		return
+	}
+	defer fs.Cleanup()
+
+	// TODO: implement
+}
+
+func TestUnixFS_Lchown(t *testing.T) {
+	t.Parallel()
+	fs, err := newTestUnixFS()
+	if err != nil {
+		t.Fatal(err)
+		return
+	}
+	defer fs.Cleanup()
+
+	// TODO: implement
+}
+
+func TestUnixFS_Chtimes(t *testing.T) {
+	t.Parallel()
+	fs, err := newTestUnixFS()
+	if err != nil {
+		t.Fatal(err)
+		return
+	}
+	defer fs.Cleanup()
+
+	// TODO: implement
+}
+
+func TestUnixFS_Create(t *testing.T) {
+	t.Parallel()
+	fs, err := newTestUnixFS()
+	if err != nil {
+		t.Fatal(err)
+		return
+	}
+	defer fs.Cleanup()
+
+	// TODO: implement
+}
+
+func TestUnixFS_Mkdir(t *testing.T) {
+	t.Parallel()
+	fs, err := newTestUnixFS()
+	if err != nil {
+		t.Fatal(err)
+		return
+	}
+	defer fs.Cleanup()
+
+	// TODO: implement
+}
+
+func TestUnixFS_MkdirAll(t *testing.T) {
+	t.Parallel()
+	fs, err := newTestUnixFS()
+	if err != nil {
+		t.Fatal(err)
+		return
+	}
+	defer fs.Cleanup()
+
+	if err := fs.MkdirAll("/a/bunch/of/directories", 0o755); err != nil {
+		t.Error(err)
+		return
+	}
+
+	// TODO: stat sanity check
+}
+
+func TestUnixFS_Open(t *testing.T) {
+	t.Parallel()
+	fs, err := newTestUnixFS()
+	if err != nil {
+		t.Fatal(err)
+		return
+	}
+	defer fs.Cleanup()
+
+	// TODO: implement
+}
+
+func TestUnixFS_OpenFile(t *testing.T) {
+	t.Parallel()
+	fs, err := newTestUnixFS()
+	if err != nil {
+		t.Fatal(err)
+		return
+	}
+	defer fs.Cleanup()
+
+	// TODO: implement
+}
+
+func TestUnixFS_ReadDir(t *testing.T) {
+	t.Parallel()
+	fs, err := newTestUnixFS()
+	if err != nil {
+		t.Fatal(err)
+		return
+	}
+	defer fs.Cleanup()
+
+	// TODO: implement
+}
+
 func TestUnixFS_Remove(t *testing.T) {
 	t.Parallel()
 	fs, err := newTestUnixFS()
@@ -154,12 +474,12 @@ func TestUnixFS_Rename(t *testing.T) {
 
 	t.Run("file rename", func(t *testing.T) {
 		// Create a directory to rename to something else.
-		if f, err := fs.Create("test_file"); err != nil {
+		f, err := fs.Create("test_file")
+		if err != nil {
 			t.Error(err)
 			return
-		} else {
-			_ = f.Close()
 		}
+		_ = f.Close()
 
 		// Try to rename "test_file" to "file".
 		if err := fs.Rename("test_file", "file"); err != nil {
@@ -175,6 +495,42 @@ func TestUnixFS_Rename(t *testing.T) {
 	})
 }
 
+func TestUnixFS_Stat(t *testing.T) {
+	t.Parallel()
+	fs, err := newTestUnixFS()
+	if err != nil {
+		t.Fatal(err)
+		return
+	}
+	defer fs.Cleanup()
+
+	// TODO: implement
+}
+
+func TestUnixFS_Lstat(t *testing.T) {
+	t.Parallel()
+	fs, err := newTestUnixFS()
+	if err != nil {
+		t.Fatal(err)
+		return
+	}
+	defer fs.Cleanup()
+
+	// TODO: implement
+}
+
+func TestUnixFS_Symlink(t *testing.T) {
+	t.Parallel()
+	fs, err := newTestUnixFS()
+	if err != nil {
+		t.Fatal(err)
+		return
+	}
+	defer fs.Cleanup()
+
+	// TODO: implement
+}
+
 func TestUnixFS_Touch(t *testing.T) {
 	t.Parallel()
 	fs, err := newTestUnixFS()
@@ -253,3 +609,160 @@ func TestUnixFS_Touch(t *testing.T) {
 		}
 	})
 }
+
+func TestUnixFS_WalkDir(t *testing.T) {
+	t.Parallel()
+	fs, err := newTestUnixFS()
+	if err != nil {
+		t.Fatal(err)
+		return
+	}
+	defer fs.Cleanup()
+
+	//for i := 0; i < 5; i++ {
+	//	dirName := "dir" + strconv.Itoa(i)
+	//	if err := fs.Mkdir(dirName, 0o755); err != nil {
+	//		t.Error(err)
+	//		return
+	//	}
+	//	for j := 0; j < 5; j++ {
+	//		f, err := fs.Create(filepath.Join(dirName, "file"+strconv.Itoa(j)))
+	//		if err != nil {
+	//			t.Error(err)
+	//			return
+	//		}
+	//		_ = f.Close()
+	//	}
+	//}
+	//
+	//if err := fs.WalkDir(".", func(path string, info ufs.DirEntry, err error) error {
+	//	if err != nil {
+	//		return err
+	//	}
+	//	t.Log(path)
+	//	return nil
+	//}); err != nil {
+	//	t.Error(err)
+	//	return
+	//}
+}
+
+func TestUnixFS_WalkDirat(t *testing.T) {
+	t.Parallel()
+	fs, err := newTestUnixFS()
+	if err != nil {
+		t.Fatal(err)
+		return
+	}
+	defer fs.Cleanup()
+
+	for i := 0; i < 2; i++ {
+		dirName := "base" + strconv.Itoa(i)
+		if err := fs.Mkdir(dirName, 0o755); err != nil {
+			t.Error(err)
+			return
+		}
+		for j := 0; j < 1; j++ {
+			f, err := fs.Create(filepath.Join(dirName, "file"+strconv.Itoa(j)))
+			if err != nil {
+				t.Error(err)
+				return
+			}
+			_ = f.Close()
+			if err := fs.Mkdir(filepath.Join(dirName, "dir"+strconv.Itoa(j)), 0o755); err != nil {
+				t.Error(err)
+				return
+			}
+			f, err = fs.Create(filepath.Join(dirName, "dir"+strconv.Itoa(j), "file"+strconv.Itoa(j)))
+			if err != nil {
+				t.Error(err)
+				return
+			}
+			_ = f.Close()
+		}
+	}
+
+	t.Run("walk starting at the filesystem root", func(t *testing.T) {
+		pathsTraversed, err := fs.testWalkDirAt("")
+		if err != nil {
+			t.Error(err)
+			return
+		}
+		expect := []Path{
+			{Name: ".", Relative: "."},
+			{Name: "base0", Relative: "base0"},
+			{Name: "dir0", Relative: "base0/dir0"},
+			{Name: "file0", Relative: "base0/dir0/file0"},
+			{Name: "file0", Relative: "base0/file0"},
+			{Name: "base1", Relative: "base1"},
+			{Name: "dir0", Relative: "base1/dir0"},
+			{Name: "file0", Relative: "base1/dir0/file0"},
+			{Name: "file0", Relative: "base1/file0"},
+		}
+		if !reflect.DeepEqual(pathsTraversed, expect) {
+			t.Log(pathsTraversed)
+			t.Log(expect)
+			t.Error("walk doesn't match")
+			return
+		}
+	})
+
+	t.Run("walk starting in a directory", func(t *testing.T) {
+		pathsTraversed, err := fs.testWalkDirAt("base0")
+		if err != nil {
+			t.Error(err)
+			return
+		}
+		expect := []Path{
+			// TODO: what should relative actually be here?
+			// The behaviour differs from walking the directory root vs a sub
+			// directory. When walking from the root, dirfd is the directory we
+			// are walking from and both name and relative are `.`. However,
+			// when walking from a subdirectory, fd is the parent of the
+			// subdirectory, and name is the subdirectory.
+			{Name: "base0", Relative: "."},
+			{Name: "dir0", Relative: "dir0"},
+			{Name: "file0", Relative: "dir0/file0"},
+			{Name: "file0", Relative: "file0"},
+		}
+		if !reflect.DeepEqual(pathsTraversed, expect) {
+			t.Log(pathsTraversed)
+			t.Log(expect)
+			t.Error("walk doesn't match")
+			return
+		}
+	})
+}
+
+type Path struct {
+	Name     string
+	Relative string
+}
+
+func (fs *testUnixFS) testWalkDirAt(path string) ([]Path, error) {
+	dirfd, name, closeFd, err := fs.SafePath(path)
+	defer closeFd()
+	if err != nil {
+		return nil, err
+	}
+	var pathsTraversed []Path
+	if err := fs.WalkDirat(dirfd, name, func(_ int, name, relative string, _ ufs.DirEntry, err error) error {
+		if err != nil {
+			return err
+		}
+		pathsTraversed = append(pathsTraversed, Path{Name: name, Relative: relative})
+		return nil
+	}); err != nil {
+		return nil, err
+	}
+	slices.SortStableFunc(pathsTraversed, func(a, b Path) int {
+		if a.Relative > b.Relative {
+			return 1
+		}
+		if a.Relative < b.Relative {
+			return -1
+		}
+		return 0
+	})
+	return pathsTraversed, nil
+}
diff --git a/internal/ufs/quota_writer.go b/internal/ufs/quota_writer.go
index 33c083f..9ba1598 100644
--- a/internal/ufs/quota_writer.go
+++ b/internal/ufs/quota_writer.go
@@ -4,7 +4,6 @@
 package ufs
 
 import (
-	"errors"
 	"io"
 	"sync/atomic"
 )
@@ -33,7 +32,7 @@ func (w *CountedWriter) BytesWritten() int64 {
 // Error returns the error from the writer if any. If the error is an EOF, nil
 // will be returned.
 func (w *CountedWriter) Error() error {
-	if errors.Is(w.err, io.EOF) {
+	if w.err == io.EOF {
 		return nil
 	}
 	return w.err
@@ -54,9 +53,8 @@ func (w *CountedWriter) Write(p []byte) (int, error) {
 	// TODO: is this how we actually want to handle errors with this?
 	if err == io.EOF {
 		return n, io.EOF
-	} else {
-		return n, nil
 	}
+	return n, nil
 }
 
 func (w *CountedWriter) ReadFrom(r io.Reader) (n int64, err error) {
@@ -92,7 +90,7 @@ func (r *CountedReader) BytesRead() int64 {
 // Error returns the error from the reader if any. If the error is an EOF, nil
 // will be returned.
 func (r *CountedReader) Error() error {
-	if errors.Is(r.err, io.EOF) {
+	if r.err == io.EOF {
 		return nil
 	}
 	return r.err
@@ -109,9 +107,9 @@ func (r *CountedReader) Read(p []byte) (int, error) {
 	r.counter.Add(int64(n))
 	r.err = err
 
+	// TODO: is this how we actually want to handle errors with this?
 	if err == io.EOF {
 		return n, io.EOF
-	} else {
-		return n, nil
 	}
+	return n, nil
 }
diff --git a/internal/ufs/walk.go b/internal/ufs/walk.go
index b0025a8..93cd306 100644
--- a/internal/ufs/walk.go
+++ b/internal/ufs/walk.go
@@ -119,5 +119,6 @@ func walkDir(fs Filesystem, name string, d DirEntry, walkDirFn WalkDirFunc) erro
 			return err
 		}
 	}
+
 	return nil
 }
diff --git a/internal/ufs/walk_unix.go b/internal/ufs/walk_unix.go
index 8472edf..7b24130 100644
--- a/internal/ufs/walk_unix.go
+++ b/internal/ufs/walk_unix.go
@@ -8,10 +8,10 @@ package ufs
 
 import (
 	"bytes"
+	"fmt"
 	iofs "io/fs"
 	"os"
 	"path"
-	"path/filepath"
 	"reflect"
 	"unsafe"
 
@@ -21,16 +21,12 @@ import (
 type WalkDiratFunc func(dirfd int, name, relative string, d DirEntry, err error) error
 
 func (fs *UnixFS) WalkDirat(dirfd int, name string, fn WalkDiratFunc) error {
-	if dirfd == 0 {
-		// TODO: proper validation, ideally a dedicated function.
-		dirfd = int(fs.dirfd.Load())
-	}
 	info, err := fs.Lstatat(dirfd, name)
 	if err != nil {
-		err = fn(dirfd, name, name, nil, err)
+		err = fn(dirfd, name, ".", nil, err)
 	} else {
 		b := newScratchBuffer()
-		err = fs.walkDir(b, dirfd, name, name, iofs.FileInfoToDirEntry(info), fn)
+		err = fs.walkDir(b, dirfd, name, ".", iofs.FileInfoToDirEntry(info), fn)
 	}
 	if err == SkipDir || err == SkipAll {
 		return nil
@@ -48,12 +44,14 @@ func (fs *UnixFS) walkDir(b []byte, parentfd int, name, relative string, d DirEn
 	}
 
 	dirfd, err := fs.openat(parentfd, name, O_DIRECTORY|O_RDONLY, 0)
+	if dirfd != 0 {
+		defer unix.Close(dirfd)
+	}
 	if err != nil {
 		return err
 	}
-	defer unix.Close(dirfd)
 
-	dirs, err := fs.readDir(dirfd, name, b)
+	dirs, err := fs.readDir(dirfd, name, relative, b)
 	if err != nil {
 		// Second call, to report ReadDir error.
 		err = walkDirFn(dirfd, name, relative, d, err)
@@ -66,20 +64,28 @@ func (fs *UnixFS) walkDir(b []byte, parentfd int, name, relative string, d DirEn
 	}
 
 	for _, d1 := range dirs {
-		// TODO: the path.Join on this line may actually be partially incorrect.
-		// If we are not walking starting at the root, relative will contain the
-		// name of the directory we are starting the walk from, which will be
-		// relative to the root of the filesystem instead of from where the walk
-		// was initiated from.
+		name := d1.Name()
+		// This fancy logic ensures that if we start walking from a subdirectory
+		// that we don't make the path relative to the root of the filesystem.
 		//
-		// ref; https://github.com/pterodactyl/panel/issues/5030
-		if err := fs.walkDir(b, dirfd, d1.Name(), path.Join(relative, d1.Name()), d1, walkDirFn); err != nil {
+		// For example, if we walk from the root of a filesystem, relative would
+		// be "." and path.Join would end up just returning name. But if relative
+		// was a subdirectory, relative could be "dir" and path.Join would make
+		// it "dir/child" even though we are walking starting at dir.
+		var rel string
+		if relative == "." {
+			rel = name
+		} else {
+			rel = path.Join(relative, name)
+		}
+		if err := fs.walkDir(b, dirfd, name, rel, d1, walkDirFn); err != nil {
 			if err == SkipDir {
 				break
 			}
 			return err
 		}
 	}
+
 	return nil
 }
 
@@ -97,7 +103,7 @@ func ReadDirMap[T any](fs *UnixFS, path string, fn func(DirEntry) (T, error)) ([
 	}
 	defer unix.Close(fd)
 
-	entries, err := fs.readDir(fd, ".", nil)
+	entries, err := fs.readDir(fd, ".", path, nil)
 	if err != nil {
 		return nil, err
 	}
@@ -112,6 +118,7 @@ func ReadDirMap[T any](fs *UnixFS, path string, fn func(DirEntry) (T, error)) ([
 		}
 		out[idx] = v
 	}
+
 	return out, nil
 }
 
@@ -157,7 +164,7 @@ func nameFromDirent(de *unix.Dirent) (name []byte) {
 //
 // When the syscall constant is not recognized, this function falls back to a
 // Stat on the file system.
-func (fs *UnixFS) modeTypeFromDirent(fd int, de *unix.Dirent, osDirname, osBasename string) (FileMode, error) {
+func (fs *UnixFS) modeTypeFromDirent(de *unix.Dirent, fd int, name string) (FileMode, error) {
 	switch de.Type {
 	case unix.DT_REG:
 		return 0, nil
@@ -176,7 +183,7 @@ func (fs *UnixFS) modeTypeFromDirent(fd int, de *unix.Dirent, osDirname, osBasen
 	default:
 		// If syscall returned unknown type (e.g., DT_UNKNOWN, DT_WHT), then
 		// resolve actual mode by reading file information.
-		return fs.modeType(fd, filepath.Join(osDirname, osBasename))
+		return fs.modeType(fd, name)
 	}
 }
 
@@ -189,12 +196,12 @@ func (fs *UnixFS) modeTypeFromDirent(fd int, de *unix.Dirent, osDirname, osBasen
 // from syscall or stat call. Therefore, mask out the additional file mode bits
 // that are provided by stat but not by the syscall, so users can rely on their
 // values.
-func (fs *UnixFS) modeType(dirfd int, name string) (os.FileMode, error) {
+func (fs *UnixFS) modeType(dirfd int, name string) (FileMode, error) {
 	fi, err := fs.Lstatat(dirfd, name)
-	if err == nil {
-		return fi.Mode() & ModeType, nil
+	if err != nil {
+		return 0, fmt.Errorf("ufs: error finding mode type for %s during readDir: %w", name, convertErrorType(err))
 	}
-	return 0, err
+	return fi.Mode() & ModeType, nil
 }
 
 var minimumScratchBufferSize = os.Getpagesize()
@@ -203,7 +210,7 @@ func newScratchBuffer() []byte {
 	return make([]byte, minimumScratchBufferSize)
 }
 
-func (fs *UnixFS) readDir(fd int, name string, b []byte) ([]DirEntry, error) {
+func (fs *UnixFS) readDir(fd int, name, relative string, b []byte) ([]DirEntry, error) {
 	scratchBuffer := b
 	if scratchBuffer == nil || len(scratchBuffer) < minimumScratchBufferSize {
 		scratchBuffer = newScratchBuffer()
@@ -220,7 +227,7 @@ func (fs *UnixFS) readDir(fd int, name string, b []byte) ([]DirEntry, error) {
 				if err == unix.EINTR {
 					continue
 				}
-				return nil, convertErrorType(err)
+				return nil, fmt.Errorf("ufs: error with getdents during readDir: %w", convertErrorType(err))
 			}
 			if n <= 0 {
 				// end of directory: normal exit
@@ -245,23 +252,29 @@ func (fs *UnixFS) readDir(fd int, name string, b []byte) ([]DirEntry, error) {
 		}
 
 		childName := string(nameSlice)
-		mt, err := fs.modeTypeFromDirent(fd, &sde, name, childName)
+		mt, err := fs.modeTypeFromDirent(&sde, fd, childName)
 		if err != nil {
-			return nil, convertErrorType(err)
+			return nil, err
+		}
+		var rel string
+		if relative == "." {
+			rel = name
+		} else {
+			rel = path.Join(relative, childName)
 		}
-		entries = append(entries, &dirent{name: childName, path: name, modeType: mt, dirfd: fd, fs: fs})
+		entries = append(entries, &dirent{dirfd: fd, name: childName, path: rel, modeType: mt, fs: fs})
 	}
 }
 
 // dirent stores the name and file system mode type of discovered file system
 // entries.
 type dirent struct {
+	dirfd    int
 	name     string
 	path     string
 	modeType FileMode
 
-	dirfd int
-	fs    *UnixFS
+	fs *UnixFS
 }
 
 func (de dirent) Name() string {
@@ -281,6 +294,7 @@ func (de dirent) Info() (FileInfo, error) {
 		return nil, nil
 	}
 	return de.fs.Lstatat(de.dirfd, de.name)
+	// return de.fs.Lstat(de.path)
 }
 
 func (de dirent) Open() (File, error) {
@@ -288,6 +302,7 @@ func (de dirent) Open() (File, error) {
 		return nil, nil
 	}
 	return de.fs.OpenFileat(de.dirfd, de.name, O_RDONLY, 0)
+	// return de.fs.OpenFile(de.path, O_RDONLY, 0)
 }
 
 // reset releases memory held by entry err and name, and resets mode type to 0.
@@ -295,4 +310,5 @@ func (de *dirent) reset() {
 	de.name = ""
 	de.path = ""
 	de.modeType = 0
+	de.dirfd = 0
 }
-- 
2.47.1.windows.1

